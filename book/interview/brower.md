## GC

### 标记删除

从一个根节点出发将可到达的对象标记，然后移除未标记的。

1. 标记空间中可达值

V8 采用的是可达性 (reachability) 算法来判断堆中的对象应不应该被回收。 这个算法的思路是这样的：

- 从根节点（Root）出发，遍历所有的对象。
- 可以遍历到的对象，是可达的（reachable）。
- 没有被遍历到的对象，不可达的（unreachable）。

在浏览器环境下，根节点有很多，主要包括这几种：

- 全局变量 window，位于每个 iframe 中
- 文档 DOM 树
- 存放在栈上的变量
- 根节点不算垃圾，不可被回收

2. 回收「不可达」的值所占据的内存

在所有的标记完成之后，统一清理内存中所有不可达的对象。

3. 做内存整理

在频繁回收对象后，内存中就会存在大量不连续空间，专业名词叫内存碎片。当内存中出现了大量的内存碎片，如果需要分配较大的连续内存时，就有可能出现内存不足的情况。所以最后一步是整理内存碎片。(但这步其实是可选的，因为有的垃圾回收器不会产生内存碎片，比如副垃圾回收器)

## 分代收集

浏览器将数据分为两种，一种是临时对象，一种是长久对象。

- 临时对象：
  - 大部分对象在内存中存活的时间很短。
  - 比如函数内部声明的变量，或者块级作用域中的变量。当函数或者代码块执行结束时，作用域中定义的变量就会被销毁。
  - 这类对象很快就变得不可访问，应该快点回收。
- 长久对象：
  - 生命周期很长的对象，比如全局的 window、DOM、Web API 等等。
  - 这类对象可以慢点回收。

这两种对象对应不同的回收策略，所以，V8 把堆分为**新生代**和**老生代**两个区域， 新生代中存放临时对象，老生代中存放持久对象。

并且让**副垃圾回收器**负责新生代的垃圾回收、**主垃圾回收器**负责老生代的垃圾回收。这样就可以实现高效的垃圾回收啦。

#### 主垃圾回收器

负责老生代的垃圾回收，有两个特点：

- 对象占用空间大。
- 对象存活时间长。

它使用**标记-清除**的算法执行垃圾回收。

1. 首先是标记

- 从一组根元素开始，递归遍历这组根元素。
- 在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。

2. 然后是垃圾清除

- 直接将标记为垃圾的数据清理掉。

3. 多次标记-清除后，会产生大量不连续的内存碎片，需要进行**内存整理**。

#### 副垃圾回收器

- 负责新生代的垃圾回收，通常只支持 1~8 M 的容量。
- 新生代被分为两个区域：一半是对象区域，一半是空闲区域。(也叫 From（使用） 空间和 To（闲置） 空间)

新加入的对象都被放入对象区域，等对象区域快满的时候，会执行一次垃圾清理。

1. 先给对象区域所有垃圾做标记。
2. 标记完成后，存活的对象被复制到空闲区域，并且将他们有序的排列一遍。
3. 复制完成后，**对象区域会和空闲区域进行对调**。将空闲区域中存活的对象放入对象区域里。

- 副垃圾回收器没有碎片整理。因为空闲区域里此时是有序的，没有碎片，也就不需要整理了。
- 因为副垃圾回收器操作比较频繁，所以为了执行效率，一般新生区的空间会被设置得比较小。
- 一旦检测到空间装满了，就执行垃圾回收。

一句话总结分代回收就是：将堆分为新生代与老生代，多回收新生代，少回收老生代。这样就减少了每次需遍历的对象，从而减少每次垃圾回收的耗时。

### 增量收集

- 如果脚本中有许多对象，引擎一次性遍历整个对象，会造成一个长时间暂停。
- 所以引擎将垃圾收集工作分成更小的块，每次处理一部分，多次处理。
- 这样就解决了长时间停顿的问题。

### 闲时收集

- 垃圾收集器只会在 CPU 空闲时尝试运行，以减少可能对代码执行的影响。

### 浏览器中不同类型变量的内存都是何时释放？

Javascritp 中类型：值类型，引用类型。

- 引用类型：
  - 在没有引用之后，通过 V8 自动回收。
- 值类型：
  - 如果处于闭包的情况下，要等闭包没有引用才会被 V8 回收。
  - 非闭包的情况下，等待 V8 的新生代切换的时候回收。

### 哪些情况会导致内存泄露？如何避免？

内存泄露是指你用不到（访问不到）的变量，依然占居着内存空间，不能被再次利用起来。

以 Vue 为例，通常有这些情况：

- 监听在 window/body 等事件没有解绑
- 绑在 EventBus 的事件没有解绑
- Vuex 的 $store，watch 了之后没有 unwatch
- 使用第三方库创建，没有调用正确的销毁函数

解决办法：beforeDestroy 中及时销毁

- 绑定了 DOM/BOM 对象中的事件 addEventListener ，removeEventListener。
- 观察者模式 $on，$off 处理。
- 如果组件中使用了定时器，应销毁处理。
- 如果在 mounted/created 钩子中使用了第三方库初始化，对应的销毁。
- 使用弱引用 weakMap、weakSet。

## 从输入 URL 到渲染页面

### 网络请求

网络请求部分进行了这几项工作：

1. URL 的解析

- **URL** 会将 URL 合并成完整的 URL `协议+主机+端口+路径[+参数][+锚点]`
- **关键字** 如果是搜索关键字，会将其拼接到默认搜索引擎的参数部分去搜索

2. 检查资源缓存

检查缓存一定是在发起真正的请求之前进行的，只有这样缓存的机制才会生效。如果发现有对应的缓存资源，则去检查缓存的有效期。

**在有效期内的**缓存资源直接使用，称之为强缓存，从 chrome 网络面板看到这类请求直接返回 200，size 是 **memory cache** 或者 **disk cache**。**memory cache** 是指从资源从内存中被取出，**disk cache** 是指从磁盘中被取出；从内存中读取比从磁盘中快很多，但资源能不能分配到内存要取决于当下的系统状态。通常来说，刷新页面会使用内存缓存，关闭后重新打开会使用磁盘缓存。

**超过有效期的**则携带缓存的资源标识向服务端发起请求，校验是否能继续使用，如果服务端告诉我们，可以继续使用本地存储，则返回 304，并且不携带数据；如果服务端告诉我们需要用更新的资源，则返回 200，并且携带更新后的资源和资源标识缓存到本地，方便下一次使用。

3. DNS 解析

DNS 解析会依次搜索:

- 浏览器的 DNS 缓存；
- 操作系统的 DNS 缓存;
- 路由器的 DNS 缓存；
- 向服务商的 DNS 服务器查询；
- 向全球 13 台根域名服务器查询；

4. 建立 TCP 连接
5. TLS 协商密钥
6. 发送请求&接收响应
7. 关闭 TCP 连接

8. 浏览器对 URL 为什么要解析？

需要对非安全字符进行转义。

10. URL 参数用的是什么字符编码？那 `encodeURI` 和 `encodeURIComponent` 有什么区别？

URL 对非安全字符转义时，使用的编码叫百分号编码，它使用百分号加上两位的 16 进制数表示。这两位 16 进制数来自 UTF-8 编码，将每一个中文转换成 3 个字节，比如我在 google 地址栏输入 “中文”，url 会变成 `/search?q=%E4%B8%AD%E6%96%87`，一共 6 个字节。

`encodeURIComponent` 会将 URL 中的 `= ? & ; /` 也转换成百分号编码，`encodeURI` 则只编码参数部分。

11. 浏览器缓存的 disk cache 和 memory cache 是什么？

12. 预加载 prefetch、preload 有什么差别？

13. JS 脚本的 async 和 defer 有什么区别？

14. TCP 握手为什么要三次，挥手为什么要四次？

15. HTTPS 的握手有了解过吗？

### 浏览器渲染

上面讲完了网络请求部分，现在浏览器拿到了数据，剩下需要渲染进程工作了。浏览器渲染主要完成了一下几个工作：

1. 构建 DOM 树；
2. 样式计算；
3. 布局定位；
4. 图层分层；
5. 图层绘制；
6. 显示；

预加载扫描器是什么?

上面提到的外链资源，不论是同步加载 JS 还是异步加载 CSS、图片等，都要到 HTML 解析到这个标签才能开始，这似乎不是一种很好的方式。实际上，从 2008 年开始，浏览器开始逐步实现了预加载扫描器：在拿到 HTML 文档的时候，先扫描整个文档，把 CSS、JS、图片和 web 字体等提前下载。js 脚本引入时

async 和 defer 有什么差别?

预加载扫描器解决了 JS 同步加载阻塞 HTML 解析的问题，但是我们还没有解决 JS 执行阻塞 HTML 解析的问题。所有有了 async 和 defer 属性。

没有 defer 或 async，浏览器会立即加载并执行指定的脚本
async 属性表示异步执行引入的 JavaScript，经加载好，就会开始执行
defer 属性表示延迟到 DOM 解析完成，再执行引入的 JS

preload、prefetch 有什么区别?

之前提到过预加载扫描器，它能提前加载页面需要的资源，但这一功能只对特定写法的外链生效，并且我们没有办法按照自己的想法给重要的资源一个更高的优先级，所以有了 preload 和 prefetch。

- preload：以高优先级为当前页面加载资源；
- prefetch：以低优先级为后面的页面加载未来需要的资源，只会在空闲时才去加载；

无论是 preload 还是 prefetch，都只会加载，不会执行，如果预加载的资源被服务器设置了可以缓存 cache-control 那么会进入磁盘，反之只会被保存在内存中。具体使用如下：

```html
<head>
  <!-- 文件加载 -->
  <link rel="preload" href="main.js" as="script" />
  <link rel="prefetch" href="news.js" as="script" />
</head>
```
